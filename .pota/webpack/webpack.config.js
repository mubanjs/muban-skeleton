import { join, resolve } from "path";
import { createMockMiddleWare } from "@mediamonks/monck";
import historyApiFallback from "connect-history-api-fallback";
import * as paths from "@pota/webpack-skeleton/.pota/webpack/paths.js";
import { createFindPlugin } from "@pota/webpack-skeleton/.pota/webpack/util.js";
import MubanPagePlugin from "./plugins/MubanPagePlugin.js";
import MiniCssExtractPlugin from "mini-css-extract-plugin";
import CopyPlugin from "copy-webpack-plugin";

const CSS_TEST = /\.css$/;
const SCSS_TEST = /\.(scss|sass)$/;

function isString(value) {
  return typeof value === "string";
}

function createMainConfig(config, { mainName, pagesName, mockApi }) {
  let { plugins } = config;

  const isDev = config.mode
    ? config.mode === "development"
    : process.env.NODE_ENV === "development";

  const findPlugin = createFindPlugin(config);
  const htmlPlugin = findPlugin("HtmlWebpackPlugin");

  plugins = plugins.filter((plugin) => plugin !== htmlPlugin);

  /** @type {import('webpack').Configuration} */
  return {
    ...config,
    name: mainName,
    output: {
      ...config.output,
      filename: `static/chunks/[name].js`,
    },
    optimization: {
      ...config.optimization,
      runtimeChunk: undefined,
      splitChunks: {
        ...config.splitChunks,
        cacheGroups: {
          ...config.cacheGroups,
          // but Muban is special and requires a single `main.css` file üòÅ
          styles: {
            name: "main",
            type: "css/mini-extract",
            chunks: "all",
            enforce: true,
          },
        },
      },
    },
    module: {
      ...config.module,
      // this overriding of `style-loader` to `MiniCssExtractPlugin.loader` would happen only during production
      // but Muban is special and requires a single `main.css` file üòÅ
      rules: config.module.rules.map((rule) => {
        if ([String(CSS_TEST), String(SCSS_TEST)].includes(String(rule.test))) {
          return {
            ...rule,
            use: rule.use.map((use) => {
              if (use === "style-loader") return MiniCssExtractPlugin.loader;
              if (!isString(use) && "loader" in use && use.loader === "sass-loader") {
                return {
                  ...use,
                  options: {
                    ...use.options,
                    // TODO: this is terribly inefficient, since we're creating a single .css file there should be a better way to add global styles
                    additionalData: `
              @import "~seng-scss";
              @import "@/styles/_global.scss";
              `,
                  },
                };
              }
              return use;
            }),
          };
        }

        return rule;
      }),
    },
    devServer: {
      ...config.devServer,
      static: {
        ...config.devServer.static,
        serveIndex: false,
      },
      historyApiFallback: false,
      onBeforeSetupMiddleware(devServer) {
        if (!devServer) {
          throw new Error("[onBeforeSetupMiddleware]: `devServer` is not defined");
        }

        if (mockApi) {
          devServer.app.use(
            "/api/",
            createMockMiddleWare(resolve(paths.user, "mocks"), { ingoreFiles: ["package.json"] })
          );
          devServer.app.use("/api/", (_, res) => res.sendStatus(404));
        }
        devServer.app.use("/", (req, res, next) => {
          if (!devServer.stats) return next();

          // find all of the `.html` assets generated by the "pages" compilation (the other config)
          const pageAssets = Array.from(
            devServer.stats.stats.find(({ compilation }) => compilation.name === pagesName)
              .compilation.emittedAssets
          ).filter((asset) => asset.endsWith(".html"));

          // setup redirects from paths to html files e.g. `/my/favourite/page` to `/my/favourite/page.html`
          return historyApiFallback({
            rewrites: pageAssets.map((asset) => ({
              from: new RegExp(`^\/${asset.replace(".html", "").replace("/index", "")}$`),
              to: `/${asset}`,
            })),
          })(req, res, next);
        });
      },
    },
    plugins: [
      ...plugins,
      // this plugin is generally applied only during production builds, but Muban is special and requires a single `main.css` file üòÅ
      new MiniCssExtractPlugin({
        ignoreOrder: true,
        filename: "static/css/[name].css",
        chunkFilename: `static/css/${isDev ? "[id]" : "[id].[contenthash]"}.css`,
      }),
    ],
  };
}

function createPagesConfig(config, { mainName, pagesName }) {
  const definePlugin = createFindPlugin(config)("DefinePlugin");

  const source = join(paths.source, "./pages");
  const publicDir = join(source, "./public");

  /** @type {import('webpack').Configuration} */
  return {
    ...config,
    mode: "development", // we do not care about the size of the output, it just needs to be built fast
    devtool: false, // source maps will not be used
    name: pagesName, // required so the `devServer` can find the correct compilation
    dependencies: [mainName], // will make webpack wait for the first
    target: "node",
    entry: { pages: resolve(source, "main.ts") },
    output: {
      ...config.output,
      // we are importing the module as a string, so we must bundle it as `commonjs`
      chunkFormat: "commonjs",
      library: { type: "commonjs" },
    },
    optimization: {
      ...config.optimization,
      minimize: false,
      moduleIds: "named",
      runtimeChunk: undefined,
    },
    // we only care about compiling the `.ts` files in the `/src/pages` directory into `.html` files
    plugins: [
      definePlugin,
      new MubanPagePlugin({ template: resolve(publicDir, "index.html") }),
      new CopyPlugin({
        patterns: [
          {
            from: publicDir,
            toType: "dir",
            globOptions: { ignore: ["**/.*", resolve(publicDir, "index.html")] },
          },
        ],
      }),
    ],
  };
}

function parseOptions(options) {
  let { preview = false, ["mock-api"]: mockApi = false } = options;

  if (preview === "false") preview = false;
  if (mockApi === "false") mockApi = false;

  return { preview, mockApi };
}

export default function createConfig(config, options = {}) {
  const isDev = config.mode
    ? config.mode === "development"
    : process.env.NODE_ENV === "development";

  const { preview, mockApi } = parseOptions(options);

  const mainName = "muban";
  const pagesName = "pages";

  /** @type {import('webpack').Configuration[]} */
  return [
    // the "main" configuration for bundling the muban app
    createMainConfig(config, { mainName, pagesName, mockApi }),
    // the "pages" configuration for bundling the static pages (also used to serve development pages)
    (preview || isDev) && createPagesConfig(config, { mainName, pagesName }),
  ].filter(Boolean);
}
